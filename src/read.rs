//! Module for representing and building read information from alignment records.
//!
//! This module defines structures and functions for extracting and representing
//! various pieces of information from read alignment records, such as bases,
//! classification, and mismatch offsets

use crate::{locus::Locus, util::Result};
use anyhow::anyhow;
use rust_htslib::bam::{record::Aux, Record};

#[derive(Debug, PartialEq, Clone)]
pub struct TrgtRead {
    /// The name of the read
    pub name: String,
    /// The sequence of bases for the read.
    pub bases: Box<[u8]>,
    /// The TRGT classification of the read.
    pub classification: Option<u8>,
    /// HP tag
    pub haplotype: Option<u8>,
    /// The start offset of the read relative to the reference and the locus start position.
    pub start_offset: Option<i32>,
    /// The end offset of the read relative to the reference and the locus end position.
    pub end_offset: Option<i32>,
    /// A list of offsets where SNPs occur between the original HiFi read and the reference relative to the locus start and end positions.
    pub mismatch_offsets: Option<Vec<i32>>,
    /// Read alignment start position
    pub pos: usize,
}

impl TrgtRead {
    pub fn new(record: &Record, locus: &Locus) -> Result<Option<Self>> {
        let qname = record.qname();

        let trid = match record.aux(b"TR") {
            Ok(Aux::String(value)) => value.to_string(),
            Ok(other) => {
                return Err(anyhow!(
                    "Read '{}' has TR tag with unexpected type: {:?}",
                    String::from_utf8_lossy(qname),
                    other
                ));
            }
            Err(_) => {
                return Err(anyhow!(
                    "Read '{}' is missing the TR tag. Was this BAM file generated by the latest version of TRGT?", String::from_utf8_lossy(qname)
                ));
            }
        };

        if trid != locus.id {
            return Ok(None);
        }

        let name = std::str::from_utf8(qname).unwrap().to_owned();

        let bases = record.seq().as_bytes().into_boxed_slice();

        let classification = match record.aux(b"AL") {
            Ok(Aux::U8(v)) => Some(v),
            Ok(Aux::I32(v)) => Some(v as u8),
            _ => None,
        };

        let haplotype = match record.aux(b"HP") {
            Ok(Aux::U8(v)) => Some(v),
            Ok(Aux::I32(v)) => Some(v as u8),
            _ => None,
        };

        let start_offset = match record.aux(b"SO") {
            Ok(Aux::I32(v)) => Some(v),
            _ => None,
        };

        let end_offset = match record.aux(b"EO") {
            Ok(Aux::I32(v)) => Some(v),
            _ => None,
        };

        let mismatch_offsets = match record.aux(b"MO") {
            Ok(Aux::ArrayI32(v)) => Some(v.iter().collect()),
            _ => None,
        };

        let pos = record.pos() as usize;

        Ok(Some(Self {
            name,
            bases,
            classification,
            haplotype,
            start_offset,
            end_offset,
            mismatch_offsets,
            pos,
        }))
    }
}

/// Builder for constructing `TrgtRead` instances with optional fields.
#[derive(Debug, PartialEq, Clone)]
pub struct TrgtReadBuilder {
    /// The name of the read
    name: String,
    /// The sequence of bases for the read.
    bases: Box<[u8]>,
    /// The TRGT classification of the read.
    classification: Option<u8>,
    /// HP tag
    haplotype: Option<u8>,
    /// The start offset of the read relative to the reference and the locus start position.
    start_offset: Option<i32>,
    /// The end offset of the read relative to the reference and the locus end position.
    end_offset: Option<i32>,
    /// A list of offsets where SNPs occur between the original HiFi read and the reference relative to the locus start and end positions.
    mismatch_offsets: Option<Vec<i32>>,
    /// Alignment start position
    pos: usize,
}

impl TrgtReadBuilder {
    pub fn with_name<T: Into<Box<[u8]>>>(mut self, name: String) -> Self {
        self.name = name;
        self
    }

    pub fn with_bases<T: Into<Box<[u8]>>>(mut self, bases: T) -> Self {
        self.bases = bases.into();
        self
    }

    pub fn with_classification(mut self, classification: Option<u8>) -> Self {
        self.classification = classification;
        self
    }

    pub fn with_haplotype(mut self, haplotype: Option<u8>) -> Self {
        self.haplotype = haplotype;
        self
    }

    pub fn with_start_offset(mut self, start_offset: Option<i32>) -> Self {
        self.start_offset = start_offset;
        self
    }

    pub fn with_end_offset(mut self, end_offset: Option<i32>) -> Self {
        self.end_offset = end_offset;
        self
    }

    pub fn with_mismatch_offsets(mut self, mismatch_offsets: Option<Vec<i32>>) -> Self {
        self.mismatch_offsets = mismatch_offsets;
        self
    }

    pub fn with_pos(mut self, pos: usize) -> Self {
        self.pos = pos;
        self
    }

    pub fn build(self) -> TrgtRead {
        TrgtRead {
            name: self.name,
            bases: self.bases,
            classification: self.classification,
            haplotype: self.haplotype,
            start_offset: self.start_offset,
            end_offset: self.end_offset,
            mismatch_offsets: self.mismatch_offsets,
            pos: self.pos,
        }
    }
}

impl Default for TrgtReadBuilder {
    fn default() -> Self {
        Self {
            name: String::new(),
            bases: Box::new([0u8; 10]),
            classification: None,
            haplotype: None,
            start_offset: None,
            end_offset: None,
            mismatch_offsets: None,
            pos: 0,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_read_info_builder() {
        let dummy_read_info = TrgtReadBuilder::default()
            .with_bases(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
            .with_classification(Some(1))
            .with_start_offset(Some(100))
            .with_end_offset(Some(200))
            .with_mismatch_offsets(Some(vec![1, 2, 3, 4, 5]))
            .build();

        assert_eq!(
            dummy_read_info.bases,
            vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into()
        );
        assert_eq!(dummy_read_info.classification, Some(1));
        assert_eq!(dummy_read_info.start_offset, Some(100));
        assert_eq!(dummy_read_info.end_offset, Some(200));
        assert_eq!(dummy_read_info.mismatch_offsets, Some(vec![1, 2, 3, 4, 5]));
    }

    #[test]
    fn test_read_info_builder_defaults() {
        let default_read_info = TrgtReadBuilder::default().build();

        assert_eq!(
            default_read_info.bases,
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0].into()
        );
        assert_eq!(default_read_info.classification, None);
        assert_eq!(default_read_info.start_offset, None);
        assert_eq!(default_read_info.end_offset, None);
        assert_eq!(default_read_info.mismatch_offsets, None);
    }
}
